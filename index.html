<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>SvelteJS</title>

    <link rel="stylesheet" href="reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="styles/theme.css" id="theme" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="styles/dracula.css" id="highlight-theme" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-background-color="white">
          <img class="r-stretch" src="images/svelte-logo-horizontal.svg" />
          <h2>Introduction to Svelte</h2>
          <div class="container">
            <div class="row">
              <div class="column">
                <p style="color: black">Narayanaperumal Gurusamy</p>
                <small style="color: #4a4a55">ngurusam@akamai.com</small>
              </div>
              <!-- <div class="column">
                <figure>
                  <img width=150 height=150 src="images/me.png" />
                </figure>
              </div> -->
            </div>
          </div>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## Prerequisites
            At minimum, it is recommended that you are familiar with the HTML, CSS, and JavaScript languages, and have knowledge of the terminal/command line.
          </script>
        </section>
        <section>
          <section data-transition="zoom">
            <h3>History</h3>
            <ul>
              <li class="fragment fade-up">First Release: end of 2016</li>
              <li class="fragment fade-up">
                Author: Richard Harris, Creator of rollup.js
              </li>
              <li class="fragment fade-up">
                v2- "Magically disappearing framework"
              </li>
              <li class="fragment fade-up">
                v3- "Cybernetically enhanced web apps"
              </li>
              <li class="fragment fade-up">Current version 3.X</li>
            </ul>
          </section>
          <section data-transition="zoom">
            <h2 class="svelte-color">What is Svelte?</h2>
            <ul>
              <li class="fragment fade-up">
                An alternative to web frameworks such as Vue, Angular, and React
              </li>
              <li class="fragment fade-up">
                A web application compiler, not a runtime library
              </li>
              <li class="fragment fade-up">
                Being a compiler, we can't just add a
                <b class="svelte-color">&lt;script src="svelte.js"&gt;</b> tag
                to our page and import it into our app.
              </li>
              <li class="fragment fade-up">Does not use a virtual DOM</li>
              <li class="fragment fade-up">
                Svelte takes inspiration from reactive programming in the way it
                runs code.
              </li>
            </ul>
          </section>
          <section data-markdown>
            <script type="text/template">
              # Reactive Programming
              - what is reactive programming?
              	- To make it short, reactive programming has key similarities with the observer pattern commonly used in OOP.

              	![Observer pattern](images/observer_pattern.jpg) <!-- .element: height="370" -->
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Reactive Programming Cont...
              > When we make a change in a cell, all the cells that depend on it, change too.
              > This makes the spreadsheet so intuitive. This is what Svelte does by default; it brings reactivity to JavaScript itself.

              ![Reactive Sheet](images/reactive_sheet.png) <!-- .element: height="370" -->
            </script>
          </section>
          <section>
            <h2>Virtual DOM vs. Svelte</h2>
            <ul>
              <li class="fragment fade-up">
                React/Vue uses a virtual DOM to interpret the application code
                during runtime.
              </li>
            </ul>
            <blockquote style="font-size: 16px" class="fragment fade-up">
              It bundles a certain amount of overhead code, which will run in
              the browser’s JavaScript engine to monitor and update the DOM. The
              virtual DOM watches for any changes and calculates the best
              possible method to make these changes to the real DOM.
            </blockquote>
            <img
              height="400"
              class="fragment fade-up"
              src="images/vdom_vs_svelte.png"
            />
          </section>
          <section data-transition="zoom">
            <h3>Svelte is a <span class="svelte-color">Compiler</span></h3>
            <div class="fragment row">
              <div class="column left-aligned">
                <ul>
                  <li>*.svelte</li>
                </ul>
              </div>
              <div class="column">
                <pre
                  data-id="code-animation"
                ><code class="hljs" data-trim data-line-numbers="3-5|7-9|11">
					// Components are the building blocks of Svelte applications.
					// They are written into .svelte files using a superset of HTML.
					<script>
						// logic goes here
					</script>
					
					<style>
						/* styles go here */
					</style>
					
					<!-- markup (zero or more HTML elements) goes here -->
				</code></pre>
              </div>
            </div>
            <div class="fragment row">
              <div class="column left-aligned">
                <ul>
                  <li>Almost No Runtime</li>
                </ul>
              </div>
              <div class="column">No runtime libraries attached.</div>
            </div>
            <div class="fragment row">
              <div class="column left-aligned">
                <ul>
                  <li>Deadcode Elimination</li>
                </ul>
              </div>
              <div class="column">
                <img
                  width="200"
                  src="https://media.slid.es/uploads/1003063/images/6900763/pasted-from-clipboard.png"
                />
                <img
                  width="200"
                  src="https://media.slid.es/uploads/1003063/images/6900768/pasted-from-clipboard.png"
                />
              </div>
            </div>
            <div class="fragment row">
              <div class="column left-aligned">
                <ul>
                  <li>Bare minimum A11Y</li>
                </ul>
              </div>
              <div class="column">
                <img
                  width="250"
                  src="https://media.slid.es/uploads/1003063/images/6900776/pasted-from-clipboard.png"
                />
              </div>
            </div>
          </section>
          <section>
            <h3>compiler output readable</h3>
            <pre>
				<code class="hljs" data-trim data-line-numbers="2-8|59-15">
					{
						c() {
						  h1 = element("h1");
						  t0 = text("Hello ");
						  t1 = text(name);
						  t4 = space();
						  img = element("img");
						},
						m(target, anchor) {
						  insert(target, h1, anchor);
						  append(h1, t0);
						  append(h1, t1);
						  insert(target, t4, anchor);
						  insert(target, img, anchor);
						}
					};
				</code>
			  </pre>
          </section>
        </section>
        <section data-markdown>
          <script type="text/template">
            # Why Svelte?
            - Svelte is Fast <!-- .element: class="fragment fade-up" -->
            	- The execution time is fast because Svelte surgically updates only the parts of the DOM that change. In contrast to React, Vue.js, and other Virtual DOM frameworks, Svelte doesn’t use a virtual DOM. <!-- .element: class="fragment fade-up" -->
            - Svelte is Small <!-- .element: class="fragment fade-up" -->
            	- When a Svelte app is compiled, the resulting bundle size is tiny compared to most other popular frameworks. <!-- .element: class="fragment fade-up" -->
            - Svelte is Compiled <!-- .element: class="fragment fade-up" -->
            	- The reason Svelte apps are so tiny is because Svelte, in addition to being a framework, is also a compiler. <!-- .element: class="fragment fade-up" -->
            - Svelte is Reactive <!-- .element: class="fragment fade-up" -->
            	- When you reassign a variable, Svelte will re-render the parts of the template that use it. <!-- .element: class="fragment fade-up" -->
          </script>
        </section>
        <section>
          <h3>How it works</h3>
          <ul>
            <li class="fragment fade-up">
              Compiler: Doesn't ship a Svelte "library" to users, but build-time
              optimized plain JS
            </li>
            <li class="fragment fade-up">
              Components: App is made up of composable UI elements
            </li>
            <li class="fragment fade-up">
              Reactive: Event/User interaction triggers chain of state changes,
              auto-updating components throughout the entire app
            </li>
          </ul>
          <img class="fragment fade-up" src="images/how-it-works.png" />
        </section>
        <section>
          <h3>UI Is a Component Tree</h3>
          <small>
            A component defines how your app should interpret some abstract
            "state" values, so that it can turn them into DOM elements in your
            browser, and ultimately pixels on your screen.
          </small>
          <img class="fragment fade-up" src="images/ui-tree.png" />
        </section>
        <section>
          <h3>The Anatomy of a Svelte Component</h3>
          <img class="fragment fade-up" src="images/anotomy.png" />
        </section>
        <section>
          <h3>The Svelte Template</h3>
          <p>
            The Svelte template allows us to use our own custom components in
            addition to HTML elements. The .svelte file extension is optional if
            there's no ambiguity, but the first letter of a custom component
            MUST be in uppercase. We can use JS expressions inside curly braces
            <b class="svelte-color">{ }</b>.
          </p>
          <img class="fragment fade-up" src="images/svelte-templates.png" />
        </section>
        <section>
          <h3>The "Props"</h3>
          <ul style="font-size: 20px">
            <li>
              A common way to "control" how a child component behaves is to pass
              data into it as props (properties).
            </li>

            <li>
              To accept a prop, expose a variable with export. It's important to
              use let because const is not reassignable.
            </li>

            <li>Setting a prop is just like doing regular HTML.</li>
          </ul>
          <img class="fragment fade-up" src="images/svelte-templates.png" />
        </section>
        <section>
          <h3>Updating Component States</h3>
          <ul style="font-size: 20px">
            <li>
              User actions trigger events. <b class="svelte-color">on:</b> lets
              us listen to events and fire functions to update states. State
              changes will auto-update the UI.
            </li>

            <li>
              Data generally flows from a parent to a child, but we can use
              <b class="svelte-color">bind:</b> to simplify the state-update
              logic by allowing two-way data flow.
            </li>
          </ul>
          <img class="fragment fade-up" src="images/update.png" />
        </section>
        <section>
          <h3><b class="svelte-color">$:</b> Reactive Statements</h3>
          <ul>
            <li>
              "Reactive statements" are those statements marked by
              <b class="svelte-color">$:</b>.
            </li>

            <li>
              Svelte analyzes which variables they depend on. When any of those
              dependencies changes, the corresponding reactive statements will
              be rerun. Very useful for declaring derived states, or triggering
              "side effects".
            </li>
          </ul>
          <img class="fragment fade-up" src="images/reactive.png" />
        </section>
        <section>
          <h3>Store</h3>
          <ul>
            <li>
              A reactive "store" makes it easy to share states across many
              components. It can exist in a separate JS file. To create a store,
              just wrap writable around a value.
            </li>

            <li>
              In a component, we prefix store names with a $ in order to
              directly use or update them. Compiler magic!
            </li>
          </ul>
          <img class="fragment fade-up" src="images/store.png" />
        </section>
        <section>
          <h3>Conditional Rendering And Lists</h3>
          <ul>
            <li>
              We can conditionally render elements with Svelte's template via
              <b class="svelte-color">{#if}</b> and optionally
              <b class="svelte-color">{:else}</b>.
            </li>

            <li>
              To render everything in a list, we have
              <b class="svelte-color">{#each}</b>.
            </li>
            <li>
              Remember to always close a block with
              <b class="svelte-color">{/if}</b> or
              <b class="svelte-color">{/each}!</b>
            </li>
          </ul>
          <img class="fragment fade-up" src="images/render.png" />
        </section>
        <section>
          <h3>Async/Await</h3>
          <ul style="font-size: 20px">
            <li>
              It's super easy to do asynchronous stuff like API requests with
              Svelte.
            </li>

            <li>
              We can simply <b class="svelte-color">{#await}</b> a Promise to
              resolve, displaying a
              <em class="svelte-color">"loading"</em> placeholder before the
              result is ready.
            </li>
            <li>
              Note that we await the Promise in the template section, so no
              await keyword in <em class="svelte-color">&lt;script&gt;</em>.
            </li>
          </ul>
          <img class="fragment fade-up" src="images/async_await.png" />
        </section>
        <section>
          <section><h1>Demo</h1></section>
          <section
            data-background-iframe="https://svelte.dev/repl/59209574d38546a1b526bad3e6af69e1?version=3.6.8"
            data-background-interactive
          ></section>
        </section>
        <section>
          <section>
            <h2>Advantages</h2>
            <ul>
              <li class="fragment fade-up">Ease of use</li>
              <ul>
                <li class="fragment fade-up">
                  Svelte is simpler to understand and get started with, as the
                  major portion of Svelte is plain JavaScript, HTML , and CSS.
                  Whereas in react we have to learn things like JSX and
                  CSS-in-JS to build the most basic applications
                </li>
              </ul>
              <li class="fragment fade-up">Write less code</li>
              <ul>
                <li class="fragment fade-up">
                  While less code doesn’t always mean better, more functional
                  code, a strong point for Svelte is how much less code you have
                  to write compared to React.
                </li>
              </ul>
            </ul>
            <div class="container fragment fade-up">
              <div class="row">
                <div class="col-6">
                  <pre><code data-trim>
                  <script>
                    let a = 1;
                    let b = 2;
                  </script>
                  
                  <input type="number" bind:value={a}>
                  <input type="number" bind:value={b}>
                  
                  <p>{a} + {b} = {a + b}</p>
                    </code></pre>
                </div>
                <div class="col-6">
                  <pre><code data-trim>
                  import React, { useState } from 'react';
                  export default () => {
                    const [a, setA] = useState(1);
                    const [b, setB] = useState(2);

                    function handleChangeA(event) {
                      setA(+event.target.value);
                    }
                    function handleChangeB(event) {
                      setB(+event.target.value);
                    }

                    return (
                      <div>
                        <input type="number" value={a} onChange={handleChangeA}/>
                        <input type="number" value={b} onChange={handleChangeB}/>
                        <p>{a} + {b} = {a + b}</p>
                      </div>
                    );
                  };
                </code></pre>
                </div>
              </div>
            </div>
          </section>
          <section>
            <h2>Cont...</h2>
            <ul>
              <li class="fragment fade-up">
                Scoped styling instead of CSS in JS.
              </li>
              <li class="fragment fade-up">
                Brilliant way of working with reactive variables – simply
                prepending a line with <b class="svelte-color">“$:"</b> will
                turn your variable into a reactive one that automatically
                updates should its value be influenced by other changes.
              </li>
              <li class="fragment fade-up">
                No virtual DOM – since the app compiles to vanilla JS, it is
                fast and immediately so.
              </li>
            </ul>
          </section>
        </section>
        <section>
          <h2>Disadvantages</h2>
          <blockquote>
            Svelte’s upsides are compelling to us, but we also need to
            understand its downsides.
          </blockquote>
          <ul>
            <li>using Svelte means adopting a new language</li>
            <li>immature tools</li>
            <li>best practices are still evolving</li>
            <li>young library ecosystem</li>
            <li>Limited number of editor extensions, syntax highlighters, component kits, devtools</li>
            <li>No support for first-class TypeScript</li>
            <li>it’s a volunteer effort</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>
                Peripheral tooling is a work in progress.Svelte is its own
                language, not plain JS, so it needs specialized tooling.
              </li>
              <li>Libraries are fewer in number and generally less mature.</li>
              <li>There’s no full-time team supporting Svelte — its developers are part-time volunteers.</li>
            </ul>
          </aside>
        </section>
        <section>
          <h2>Should I invest my time in Svelte?</h2>
          <aside class="notes">
            With all that said, there is one more question that might have already occurred to you: isn’t that all just a little bit too perfect? Well, the truth is that being a fairly new framework, Svelte’s ecosystem is still maturing, which may prove troublesome for large projects. As of today, Svelte-generated code is also not compatible with Internet Explorer 11 (requires quite a lot of polyfills in order to run the app in IE 11 and older versions of the browser).

But since it can be used in conjunction with other frameworks, there is no need for you to give up on other choices. Who knows, perhaps in time the decision to invest some effort in Svelte will prove extremely beneficial for your development team? With little risk involved, there is no hurt in trying.

The Software House has also already tested the new framework, having used it for an internal project of a game app called TypeRunner.js – a simple typing game which has 2-4 users compete against each other in real time. The backend for this simple game was based on Node.js. And if you find Svelte to be interesting, you should also put some effort into developing a simple Svelte-based project on your own. It is by far the best way to get enough confidence to actually use it in a serious commercial work.
          </aside>
        </section>
        <section>
          <h1>Q&A</h1>
        </section>
        <section>
          <h1>Thank You</h1>
        </section>
      </div>
    </div>

    <script src="reveal.js/dist/reveal.js"></script>
    <script src="reveal.js/plugin/notes/notes.js"></script>
    <script src="reveal.js/plugin/markdown/markdown.js"></script>
    <script src="reveal.js/plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        backgroundTransition: "convex",
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
